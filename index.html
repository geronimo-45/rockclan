<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RockClan Records</title>

  <!-- âœ… React / ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" defer></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" defer></script>

  <!-- âœ… PropTypes (ì „ì—­ ì£¼ì…: Rechartsë³´ë‹¤ ë°˜ë“œì‹œ ë¨¼ì € ë¡œë“œ) -->
  <script src="https://unpkg.com/prop-types@15.8.1/prop-types.min.js" defer></script>

  <!-- âœ… ì•ˆì • ë²„ì „ Recharts (ë²„ê·¸ íšŒí”¼) -->
  <script src="https://cdn.jsdelivr.net/npm/recharts@2.10.3/umd/Recharts.min.js" defer></script>

  <!-- favicon 404 ì–µì œ -->
  <link rel="icon" type="image/x-icon" href="data:;base64,iVBORw0KGgo=">

  <style>
    :root {
      --bg1:#0b0710; --bg2:#14050a; --accent:#ff6a00; --muted:#a7a0a8; --card:rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box}
    body{
      font-family:system-ui,-apple-system,'Segoe UI',Roboto,'Noto Sans KR','Apple SD Gothic Neo','Malgun Gothic',sans-serif;
      margin:0;color:#eee;
      background:linear-gradient(180deg,var(--bg1),var(--bg2));
    }
    header{
      padding:20px;text-align:center;
      background:linear-gradient(90deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));
      box-shadow:0 6px 30px rgba(0,0,0,0.5)
    }
    header h1{margin:0;color:var(--accent)}
    header .sub{color:var(--muted);font-size:13px;margin-top:6px}
    nav{
      display:flex;gap:10px;justify-content:center;
      padding:10px;background:#14141a;position:sticky;top:0;z-index:2
    }
    nav button{
      background:#1a1a22;border:1px solid #232532;color:#ddd;
      padding:10px 14px;border-radius:10px;cursor:pointer
    }
    nav button.active{background:var(--accent);color:#111}
    main{max-width:1100px;margin:18px auto;padding:0 16px}
    section{display:none}
    section.active{display:block}
    .card{
      background:var(--card);padding:14px;border-radius:12px;
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);margin-bottom:16px
    }
    table{width:100%;border-collapse:collapse}
    th,td{
      padding:8px 10px;border-bottom:1px solid rgba(255,255,255,0.06);
      text-align:center
    }
    th{color:var(--muted);font-size:12px;text-transform:uppercase}
    tr:hover{background:rgba(255,255,255,0.03)}
    .tier-Stone{color:#8b8b8b}
    .tier-Bronze{color:#cd7f32}
    .tier-Silver{color:#c0c0c0}
    .tier-Gold{color:#ffd700}
    .tier-Diamond{color:#67e8f9}
    .tier-Legend{color:#ff7f50}
    .muted{color:var(--muted)}
    .filters{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
    .filters>*{flex:1 1 160px}
    .match{
      border:1px solid rgba(255,255,255,0.08);padding:10px;border-radius:10px;
      background:rgba(255,255,255,0.02);margin-bottom:10px
    }
    .match-header{font-weight:700;margin-bottom:6px;cursor:pointer;color:#ffb347}
    .match-item{color:#ddd;font-size:14px;margin:4px 0;padding-left:8px}
    .hidden{display:none;}
    
    /* íƒ­ í™œì„±í™” ìƒ‰ìƒ ì¼ê´€ ì ìš© */
.month-tab.active,
.old-season-tab.active {
  background: var(--accent) !important;
  color: #111 !important;
  font-weight: 700;
}

    /* Old Records ì „ìš© í…Œì´ë¸” í°íŠ¸ */
.old-records-table th,
.old-records-table td {
  font-size: 14px;
}


  </style>
</head>

<body>
  <header>
    <h1>RockClan Records</h1>
    <div class="sub">í´ëœì› ë­í‚¹ â€¢ ê¸°ë¡ì‹¤ â€¢ Old Records â€¢ ELO ì‹œìŠ¤í…œ ì„¤ëª… â€¢ ìƒëŒ€ ì „ì  ì¡°íšŒ</div>
  </header>

  <nav>
    <button class="tab active" data-tab="players">í´ëœì› ë­í‚¹</button>
    <button class="tab" data-tab="records">ê¸°ë¡ì‹¤</button>
    <button class="tab" data-tab="old-records">Old Records</button>
    <button class="tab" data-tab="elo-info">ELO ì‹œìŠ¤í…œ ì„¤ëª…</button>
    <button class="tab" data-tab="h2h">ìƒëŒ€ ì „ì  ì¡°íšŒ</button>
  </nav>

  <!-- ğŸ”¹ í”Œë ˆì´ì–´ íˆìŠ¤í† ë¦¬ íŒì—… -->
  <div id="playerModal" class="modal" style="position:fixed;z-index:1000;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.6);padding-top:60px;display:none;">
    <div class="modal-content" style="background:#1a1a22;margin:auto;padding:20px;border-radius:12px;width:85%;max-height:80%;overflow-y:auto;color:#eee;box-shadow:0 0 20px rgba(0,0,0,.6)">
      <span id="closeModal" class="close" style="float:right;font-size:28px;cursor:pointer;color:#aaa">&times;</span>
      <h2 id="modalPlayerName" style="color:#ff6a00;margin-top:0;"></h2>
      <div id="modalPlayerInfo" style="font-size:14px;margin-bottom:12px;color:#ccc;"></div>
      <canvas id="modalEloChart" width="600" height="250" style="background:#111;border-radius:8px;margin-bottom:16px;"></canvas>
      <div id="modalMatchHistory" style="font-size:14px;color:#ddd;"></div>
    </div>
  </div>

  <main>
    <!-- ë­í‚¹ -->
    <section id="players" class="active">
      <div class="card">
        <h2 style="margin:6px 0;color:var(--accent)">í´ëœì› ë­í‚¹</h2>
        <div class="filters">
          <input id="search" placeholder="ID ê²€ìƒ‰" style="padding:10px;border-radius:8px;border:1px solid #2c2f3a;background:#101018;color:#fff;">
          <select id="raceFilter" style="padding:10px;border-radius:8px;border:1px solid #2c2f3a;background:#101018;color:#fff;">
            <option value="">ì¢…ì¡± ì „ì²´</option>
            <option>Protoss</option><option>Terran</option><option>Zerg</option><option>Random</option>
          </select>
          <select id="tierFilter" style="padding:10px;border-radius:8px;border:1px solid #2c2f3a;background:#101018;color:#fff;">
            <option value="">í‹°ì–´ ì „ì²´</option>
            <option>Stone</option><option>Bronze</option><option>Silver</option><option>Gold</option><option>Diamond</option><option>Legend</option>
          </select>
          <!-- ğŸ“… ë­í‚¹ ê¸°ì¤€ ë‚ ì§œ ì„ íƒ (ìº˜ë¦°ë”) -->
          <input id="rankDate" type="date" style="padding:10px;border-radius:8px;border:1px solid #2c2f3a;background:#101018;color:#fff;">
        </div>
        <div class="muted" style="font-size:13px;margin-bottom:2px">
          2026 ì‹œì¦Œ1 (1ì›” 1ì¼ ~ 6ì›” 30ì¼) ê²½ê¸° ê¸°ì¤€ ë­í‚¹ì…ë‹ˆë‹¤. (ë‹¬ë ¥ì—ì„œ ë‚ ì§œë¥¼ ì„ íƒí•˜ë©´ í•´ë‹¹ ì‹œì¦Œ ë‚´ ì‹œì  ê¸°ì¤€ ë­í‚¹ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)
        </div>
        <div class="muted" id="rankDateLabel" style="font-size:12px;margin-bottom:6px"></div>
        <table id="players-table">
          <thead><tr><th>Rank</th><th>ID</th><th>ì¢…ì¡±</th><th>í‹°ì–´</th><th>ELO</th><th>ìŠ¹</th><th>íŒ¨</th><th>ìŠ¹ë¥ </th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- ê¸°ë¡ì‹¤ -->
    <section id="records">
      <div class="card">
        <h2 style="margin:6px 0;color:var(--accent)">ê¸°ë¡ì‹¤</h2>
        <div id="records-months" class="filters" style="margin-bottom:10px;"></div>
        <div id="match-list"></div>
      </div>
    </section>

    <!-- Old Records -->
    <section id="old-records">
      <div class="card">
        <h2 style="margin:6px 0;color:var(--accent)">Old Records</h2>
        <div class="muted" style="font-size:12px">
          ì´ì „ ì‹œì¦Œ(ì™„ë£Œëœ ì‹œì¦Œ)ì˜ ìµœì¢… ELO ë­í‚¹ì…ë‹ˆë‹¤. ì•„ë˜ì—ì„œ ì‹œì¦Œì„ ì„ íƒí•˜ì„¸ìš”.
        </div>
        <div id="oldSeasonTabs" class="filters" style="margin-top:10px;"></div>
        <div id="oldSeasonContent" style="margin-top:10px;"></div>
      </div>
    </section>

    <!-- ELO ì„¤ëª… -->
    <section id="elo-info">
      <div class="card">
        <h2 style="margin:6px 0;color:var(--accent)">ELO ì‹œìŠ¤í…œ ì„¤ëª…</h2>

        <p style="line-height:1.6;color:#ddd">
          RockClanì˜ ELO ì‹œìŠ¤í…œì€ ë‹¨ìˆœí•œ ì ìˆ˜ ì°¨ì´ë¿ ì•„ë‹ˆë¼ <b>í‹°ì–´(Tier) ë³´ì •</b>ì„ í¬í•¨í•˜ì—¬ ì‹¤ì œ ì‹¤ë ¥ ê²©ì°¨ë¥¼ ë°˜ì˜í•©ë‹ˆë‹¤.<br>
          ëª¨ë“  ê³„ì‚°ì€ ê¸°ë¡ì‹¤(match) ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìë™ ìˆ˜í–‰ë©ë‹ˆë‹¤.
        </p>

        <ul style="line-height:1.8;color:#ccc;margin-left:12px">
          <li><b>ì´ˆê¸° ELO</b>: ì‹ ê·œ í”Œë ˆì´ì–´ëŠ” 1000ì ìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤.</li>
          <li><b>K ê°’</b>:
            <ul>
              <li>ê°œì¸ì „(1:1): <b>K = 12</b></li>
              <li>íŒ€ì „(2:2, 3:3, 4:4 ë“±): <b>K = 8</b></li>
            </ul>
          </li>
          <li><b>í‹°ì–´ ì¸ë±ìŠ¤ ë³´ì •</b>:
            <ul>
              <li>Stone=0, Bronze=1, Silver=2, Gold=3, Diamond=4, Legend=5</li>
              <li>ì‹¤ì œ ê³„ì‚°ì€ <code>EffectiveElo = ELO + (TierIndex Ã— 40)</code> ìœ¼ë¡œ ìˆ˜í–‰ë©ë‹ˆë‹¤.</li>
            </ul>
          </li>
          <li>ì˜ˆìƒ ìŠ¹ë¥ ì€ ë‘ í”Œë ˆì´ì–´ì˜ <b>EffectiveElo</b> ì°¨ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°ë©ë‹ˆë‹¤.</li>
          <li>ê²½ê¸° ê²°ê³¼ëŠ” ì˜ˆìƒ ìŠ¹ë¥  ëŒ€ë¹„ ì‹¤ì œ ìŠ¹íŒ¨ ì°¨ì´ë§Œí¼ ELOê°€ ë³€ë™í•©ë‹ˆë‹¤.</li>
        </ul>

        <h3 style="margin-top:16px;color:var(--accent)">ğŸ“ˆ ELO ê³„ì‚° ì˜ˆì‹œ</h3>
        <table style="width:100%;border-collapse:collapse;margin-top:8px;font-size:14px;color:#ddd">
          <thead>
            <tr style="background:rgba(255,255,255,0.05)">
              <th style="padding:6px;border:1px solid rgba(255,255,255,0.1)">ìƒí™©</th>
              <th style="padding:6px;border:1px solid rgba(255,255,255,0.1)">ELO ì°¨ì´</th>
              <th style="padding:6px;border:1px solid rgba(255,255,255,0.1)">í‹°ì–´ ì°¨ì´</th>
              <th style="padding:6px;border:1px solid rgba(255,255,255,0.1)">ì˜ˆìƒ ìŠ¹ë¥ </th>
              <th style="padding:6px;border:1px solid rgba(255,255,255,0.1)">ìŠ¹ë¦¬ ì‹œ</th>
              <th style="padding:6px;border:1px solid rgba(255,255,255,0.1)">íŒ¨ë°° ì‹œ</th>
            </tr>
          </thead>
          <tbody>
            <tr><td style="padding:6px;border:1px solid rgba(255,255,255,0.1)">1:1 (ë™í‹°ì–´, ë™ì¼ ELO)</td><td>0</td><td>0</td><td>50%</td><td>+6</td><td>âˆ’6</td></tr>
            <tr><td style="padding:6px;border:1px solid rgba(255,255,255,0.1)">Silver(2) vs Gold(3)</td><td>0</td><td>+1</td><td>46%</td><td>+7</td><td>âˆ’5</td></tr>
            <tr><td style="padding:6px;border:1px solid rgba(255,255,255,0.1)">Gold(3) vs Silver(2)</td><td>0</td><td>âˆ’1</td><td>54%</td><td>+5</td><td>âˆ’7</td></tr>
            <tr><td style="padding:6px;border:1px solid rgba(255,255,255,0.1)">íŒ€ì „ (í‰ê·  ë™í‹°ì–´)</td><td>0</td><td>0</td><td>50%</td><td>+4</td><td>âˆ’4</td></tr>
            <tr><td style="padding:6px;border:1px solid rgba(255,255,255,0.1)">íŒ€ì „ (ìƒëŒ€íŒ€ í‰ê·  Diamondâ†‘)</td><td>âˆ’150</td><td>+2</td><td>32%</td><td>+6</td><td>âˆ’3</td></tr>
          </tbody>
        </table>

        <p style="margin-top:10px;color:#999">
          â€» ELO ê³„ì‚°ì‹: <code>NewElo = OldElo + K Ã— (Actual âˆ’ Expected)</code><br>
          â€» í‹°ì–´ ì¸ë±ìŠ¤ ë³´ì •ìœ¼ë¡œ ì¸í•´ ìƒìœ„ í‹°ì–´ë¥¼ ì´ê¸¸ ê²½ìš° ìƒìŠ¹í­ì´ ë” ì»¤ì§‘ë‹ˆë‹¤.
        </p>

        <!-- ğŸ”¹ ì‹œë®¬ë ˆì´í„° -->
        <h3 style="margin-top:30px;color:var(--accent)">ğŸ§® ELO ê³„ì‚° ì‹œë®¬ë ˆì´í„°</h3>
        <div style="color:#ddd;font-size:14px;line-height:1.8;">
          <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:10px;">
            <label>í”Œë ˆì´ì–´ A ELO <input id="eloA" type="number" value="1000" style="width:80px;margin-left:6px;padding:4px;background:#111;border:1px solid #333;color:#fff;"></label>
            <label>í‹°ì–´
              <select id="tierA" style="padding:4px;background:#111;border:1px solid #333;color:#fff;">
                <option>Stone</option><option>Bronze</option><option selected>Silver</option><option>Gold</option><option>Diamond</option><option>Legend</option>
              </select>
            </label>
            <span style="margin:0 12px;">vs</span>
            <label>í”Œë ˆì´ì–´ B ELO <input id="eloB" type="number" value="1000" style="width:80px;margin-left:6px;padding:4px;background:#111;border:1px solid #333;color:#fff;"></label>
            <label>í‹°ì–´
              <select id="tierB" style="padding:4px;background:#111;border:1px solid #333;color:#fff;">
                <option>Stone</option><option>Bronze</option><option>Silver</option><option selected>Gold</option><option>Diamond</option><option>Legend</option>
              </select>
            </label>
            <label style="margin-left:16px;">ê²½ê¸° íƒ€ì…
              <select id="gameType" style="padding:4px;background:#111;border:1px solid #333;color:#fff;">
                <option value="1v1" selected>1:1</option>
                <option value="team">íŒ€ì „</option>
              </select>
            </label>
            <button id="calcBtn" style="margin-left:12px;padding:6px 12px;border:none;border-radius:6px;background:var(--accent);color:#111;cursor:pointer;">ê³„ì‚°</button>
          </div>

          <div id="simResult" style="margin-top:10px;padding:10px;border:1px solid rgba(255,255,255,0.1);border-radius:8px;background:rgba(255,255,255,0.03);">
            ê³„ì‚° ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.
          </div>
        </div>

        <script>
          document.getElementById("calcBtn").addEventListener("click",()=>{
            const getTierIndex=t=>["Stone","Bronze","Silver","Gold","Diamond","Legend"].indexOf(t);
            const eloA=parseFloat(document.getElementById("eloA").value||1000);
            const eloB=parseFloat(document.getElementById("eloB").value||1000);
            const tierA=document.getElementById("tierA").value;
            const tierB=document.getElementById("tierB").value;
            const gameType=document.getElementById("gameType").value;
            const K=(gameType==="team")?8:12;

            const effA=eloA+getTierIndex(tierA)*40;
            const effB=eloB+getTierIndex(tierB)*40;
            const expectedA=1/(1+Math.pow(10,(effB-effA)/400));
            const deltaWin = K*(1-expectedA);
            const deltaLose = -K*(expectedA);
            const winPct=(expectedA*100).toFixed(1);

            document.getElementById("simResult").innerHTML=`
              <div><b>ì˜ˆìƒ ìŠ¹ë¥ </b>: A ${winPct}% / B ${(100-expectedA*100).toFixed(1)}%</div>
              <div><b>Kê°’</b>: ${K}</div>
              <div><b>A ìŠ¹ë¦¬ ì‹œ</b>: A +${deltaWin.toFixed(2)} / B ${deltaLose.toFixed(2)}</div>
              <div><b>B ìŠ¹ë¦¬ ì‹œ</b>: A ${(-deltaWin).toFixed(2)} / B +${(-deltaLose).toFixed(2)}</div>
            `;
          });
        </script>

      </div>
    </section>

    <!-- ìƒëŒ€ ì „ì  ì¡°íšŒ -->
    <section id="h2h">
      <div class="card">
        <h2 style="margin:6px 0;color:var(--accent)">ìƒëŒ€ ì „ì  ì¡°íšŒ</h2>
        <div class="muted" style="margin-top:6px">
          Player#1ì€ í•„ìˆ˜, Player#2ëŠ” ì„ íƒì…ë‹ˆë‹¤. Player#2ë¥¼ ë¹„ìš°ë©´ Player#1ì´ ìƒëŒ€í–ˆë˜ ì‚¬ëŒ ëª©ë¡ì´ í‘œì‹œë©ë‹ˆë‹¤. (â–¼ë¡œ ë‚ ì§œ/ë§µ/ìŠ¤ì½”ì–´ í™•ì¸)
        </div>

        <div class="filters" style="margin-top:12px">
          <select id="h2hP1" style="padding:10px;border-radius:8px;border:1px solid #2c2f3a;background:#101018;color:#fff;">
            <option value="">Player#1 ì„ íƒ (í•„ìˆ˜)</option>
          </select>

          <select id="h2hP2" style="padding:10px;border-radius:8px;border:1px solid #2c2f3a;background:#101018;color:#fff;">
            <option value="">Player#2 ì„ íƒ (ì„ íƒ)</option>
          </select>

          <button id="h2hSearchBtn" style="padding:10px 14px;border:none;border-radius:10px;background:var(--accent);color:#111;cursor:pointer;flex:0 0 auto">ì¡°íšŒ</button>
          <button id="h2hClearBtn" style="padding:10px 14px;border:1px solid #232532;border-radius:10px;background:#1a1a22;color:#ddd;cursor:pointer;flex:0 0 auto">ì´ˆê¸°í™”</button>
        </div>

        <div id="h2hResult" style="margin-top:12px"></div>
      </div>
    </section>

  </main>

  <!-- âœ… Chart.js ë¡œë“œ (defer ì¶”ê°€) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>

  <!-- âœ… ìŠ¤í¬ë¦½íŠ¸ -->
  <script>
  (function(){
    // --- íƒ­ ì „í™˜ ---
    document.querySelectorAll('nav .tab').forEach(btn=>{
      btn.addEventListener('click', e=>{
        document.querySelectorAll('nav .tab').forEach(b=>b.classList.remove('active'));
        e.currentTarget.classList.add('active');
        document.querySelectorAll('main section').forEach(s=>s.classList.remove('active'));
        document.getElementById(e.currentTarget.dataset.tab).classList.add('active');
      });
    });

    // --- ì•ˆì „ ë¡œë” ---
    const safe = async (url) => {
      try {
        const res = await fetch(url + (url.includes('?')?'&':'?') + 'v=' + Date.now(), { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const txt = await res.text();
        try { return JSON.parse(txt); }
        catch (e) { console.error('âŒ JSON íŒŒì‹± ì‹¤íŒ¨:', url, txt.slice(0,200)); return {players:[], matches:[]}; }
      } catch (e) {
        console.error('âŒ ë¡œë“œ ì‹¤íŒ¨:', url, e);
        return {players:[], matches:[]};
      }
    };

    const basePath = location.pathname.replace(/[^\/]*$/, '');
    const path = (name) => basePath + name;

    const TierOrder=['Stone','Bronze','Silver','Gold','Diamond','Legend'];
    const getTierIndex = t => Math.max(0, TierOrder.indexOf(t||'Silver'));
    const toMMDD = d => d ? d.split('-').slice(1).join('/') : '';

    const $search = document.getElementById('search');
    const $race   = document.getElementById('raceFilter');
    const $tier   = document.getElementById('tierFilter');
    const $rankDate = document.getElementById('rankDate');
    const $rankDateLabel = document.getElementById('rankDateLabel');

    // ğŸ”¹ ì‹œì¦Œ ì •ì˜
    const SEASONS = [
      { key:'2025',   label:'2025 ì‹œì¦Œ',   start:null,          end:'2025-12-31' },
      { key:'2026S1', label:'2026 ì‹œì¦Œ1', start:'2026-01-01', end:'2026-06-30' },
      { key:'2026S2', label:'2026 ì‹œì¦Œ2', start:'2026-07-01', end:'2026-12-31' },
    ];
    
    // ğŸ”¹ ì‹œì¦Œë³„ í‹°ì–´ ìŠ¤ëƒ…ìƒ· (Old Records ì „ìš©)
    // 2025 ì‹œì¦Œì´ ëë‚œ ì‹œì ì˜ í‹°ì–´ë¥¼ ì—¬ê¸° ê¸°ë¡í•´ë‘ë©´,
    // ë‚˜ì¤‘ì— data.jsonì—ì„œ í‹°ì–´ë¥¼ ë°”ê¿”ë„ Old Records(2025 ì‹œì¦Œ) ê²°ê³¼ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€ëœë‹¤.
    const SEASON_TIER_SNAPSHOT = {
      '2025': {
        'Attaboy': 'Diamond',
        'Basic': 'Silver',
        'Chan': 'Silver',
        'DanielK': 'Silver',
        'Essence': 'Bronze',
        'Friend': 'Silver',
        'Gdragon': 'Diamond',
        'GgoMajin': 'Silver',
        'Hani': 'Gold',
        'Hyunho': 'Silver',
        'IN': 'Gold',
        'MGZG': 'Bronze',
        'Macho': 'Diamond',
        'MiSTY': 'Silver',
        'Miny': 'Silver',
        'Mukddak': 'Silver',
        'Rocky': 'Silver',
        'Rupark': 'Diamond',
        'Shinny': 'Legend',
        'Skidashi': 'Gold',
        'Strive': 'Legend',
        'Templar': 'Gold',
        'Veeny': 'Gold',
        'Winter': 'Gold',
        'Yolo': 'Diamond',
        'umi': 'Bronze',
        'Zeze': 'Gold',
        'coolguy': 'Silver',
        'dong9': 'Diamond',
        'dopamine': 'Diamond',
        'dalsun2': 'Diamond',
        'qooqoo': 'Silver',
        'ToTo': 'Diamond',
        'eun': 'Silver',
        '5making': 'Gold',
        'Jangbi': 'Silver',
        'Pang': 'Gold',
        'SunnySea': 'Diamond',
        'JeJu': 'Diamond',
        'Nangman': 'Gold',
        'PE': 'Diamond',
        'JoJo': 'Bronze'
      }
      // ë‚˜ì¤‘ì— 2026 ì‹œì¦Œ1ì´ ëë‚œ ë’¤ì— ìŠ¤ëƒ…ìƒ·ì„ ê³ ì •í•˜ê³  ì‹¶ìœ¼ë©´
      // ì—¬ê¸°ì— '2026S1': { ... } í˜•íƒœë¡œ í•œ ë²ˆ ë” ì¶”ê°€í•˜ë©´ ë¨.
    };

    // ğŸ”¹ í˜„ì¬ ì‹œì¦Œ ì„¤ì • (ì§€ê¸ˆì€ 2026 ì‹œì¦Œ1)
    const CURRENT_SEASON_KEY = '2026S1';
    const CURRENT_SEASON = SEASONS.find(s => s.key === CURRENT_SEASON_KEY) || SEASONS[0];

    // ğŸ”¹ íƒˆí‡´/ìˆ¨ê¹€ ID
    const HIDE_IDS = new Set(['Wonder','ceta']);

    const isInSeason = (match, season)=>{
      if(!season) return false;
      const d = String(match.date || '');
      if(!d) return false;
      if(season.start && d < season.start) return false;
      if(season.end   && d > season.end)   return false;
      return true;
    };

    start();

    async function start() {
      const base = await safe(path('data.json'));

      // ğŸ”¹ ì¶”ê°€ ì›” ë°ì´í„° ë¡œë“œ (í•„ìš”ì‹œ ì—¬ê¸°ë§Œ ìˆ˜ì •)
      const months = ['oct','nov','dec','jan']; // data_oct.json, data_nov.json, data_dec.json, data_jan.json ...

      for (const m of months) {
        try {
          const data = await safe(path(`data_${m}.json`));
          base.matches = (base.matches || []).concat(data.matches || []);
          const seen = new Set((base.players || []).map(p => p.id));
          (data.players || []).forEach(p => { if (!seen.has(p.id)) base.players.push(p); });
        } catch (err) {
          console.warn(`âš ï¸ data_${m}.json ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:`, err);
        }
      }

      renderAll(base);
    }

    function renderAll(data){
      const playersMeta = new Map((data.players||[]).map(p=>[p.id,p]));
      const stat = new Map();
      const eloByDate = {};

      const ensure = (id)=>{
        if(stat.has(id)) return stat.get(id);
        const m=playersMeta.get(id)||{};
        const o={ id, elo:1000, tier:m.tier||'Silver', race:m.race||'Protoss', win:0, loss:0, played:0 };
        stat.set(id,o); return o;
      };

      const calc = (A,B,res,isTeam)=>{
        const K = isTeam? 8 : 12;
        const effA = A.elo + getTierIndex(A.tier)*40;
        const effB = B.elo + getTierIndex(B.tier)*40;
        const expectedA = 1/(1+Math.pow(10,(effB-effA)/400));
        const delta = K*(res-expectedA);
        A.elo += delta; B.elo -= delta;
      };

      const matchesAll = (data.matches||[]).slice().sort((a,b)=>String(a.date).localeCompare(String(b.date)));

      // âœ… í˜„ì¬ ì‹œì¦Œ(2026 ì‹œì¦Œ1) ë­í‚¹ ê³„ì‚°ì— ì‚¬ìš©í•  ê²½ê¸°ë§Œ ì¶”ì¶œ
      const matchesForRanking = matchesAll.filter(m => isInSeason(m, CURRENT_SEASON));

      // --- ë­í‚¹ìš© ë‚ ì§œ ë²”ìœ„ ê³„ì‚° (ë‹¬ë ¥ min/max ì„¸íŒ…ìš©) ---
      let minRankDate = null;
      let maxRankDate = null;
      for (const m of matchesForRanking) {
        if (!m || !m.date || !m.map || m.map === 'Match') continue;
        const d = String(m.date);
        if (!minRankDate || d < minRankDate) minRankDate = d;
        if (!maxRankDate || d > maxRankDate) maxRankDate = d;
      }

      // ğŸ”¹ í˜„ì¬ ì‹œì¦Œ ê¸°ì¤€ ELO ëˆ„ì 
      for(const m of matchesForRanking){
        if(!m.map || m.map==='Match') continue;
        const d = toMMDD(m.date);

        if(m.player1 && m.player2){
          const p1=ensure(m.player1), p2=ensure(m.player2);
          if(m.winner===m.player1){ calc(p1,p2,1,false); p1.win++; p2.loss++; }
          else if(m.winner===m.player2){ calc(p1,p2,0,false); p2.win++; p1.loss++; }
          p1.played++; p2.played++;
          (eloByDate[p1.id]??={})[d]=Math.round(p1.elo);
          (eloByDate[p2.id]??={})[d]=Math.round(p2.elo);
        }

        if(Array.isArray(m.team1) && Array.isArray(m.team2)){
          const T1=m.team1.map(ensure), T2=m.team2.map(ensure);
          const winners = Array.isArray(m.winner)? m.winner : [];
          const win1 = winners.some(x=>m.team1.includes(x)) ? 1 : 0;

          const avg1=T1.reduce((a,b)=>a+b.elo,0)/T1.length;
          const avg2=T2.reduce((a,b)=>a+b.elo,0)/T2.length;
          const dA={elo:avg1,tier:'Silver'}, dB={elo:avg2,tier:'Silver'};
          calc(dA,dB,win1,true);
          const diffA=dA.elo-avg1, diffB=dB.elo-avg2;

          T1.forEach(p=>{ p.elo+=diffA; p.played++; win1?p.win++:p.loss++; (eloByDate[p.id]??={})[d]=Math.round(p.elo); });
          T2.forEach(p=>{ p.elo+=diffB; p.played++; !win1?p.win++:p.loss++; (eloByDate[p.id]??={})[d]=Math.round(p.elo); });
        }
      }

      // --- ë­í‚¹ í‘œì‹œ (ELO ë‚´ë¦¼ì°¨ìˆœ) + í•„í„° ---
      const tbody = document.querySelector('#players-table tbody');

      let baseRows = [...stat.values()]
        .filter(p => !HIDE_IDS.has(p.id))
        .sort((a,b)=>b.elo-a.elo);

      let activeRows = baseRows;

      function applyFilters(){
        const q = ($search.value||'').trim().toLowerCase();
        const r = $race.value||'';
        const t = $tier.value||'';

        const filtered = activeRows.filter(p=>{
          if(q && !p.id.toLowerCase().includes(q)) return false;
          if(r && p.race!==r) return false;
          if(t && p.tier!==t) return false;
          return true;
        });

        tbody.innerHTML = filtered.map((p,i)=>{
          const wr = p.played? ((p.win/p.played)*100).toFixed(1) : '0.0';
          return `<tr>
            <td>${i+1}</td><td>${p.id}</td><td>${p.race}</td>
            <td class="tier-${p.tier}">${p.tier}</td>
            <td>${Math.round(p.elo)}</td><td>${p.win}</td><td>${p.loss}</td><td>${wr}%</td>
          </tr>`;
        }).join('');
      }

      function updateRankDateLabel(iso, noGames){
        if(!$rankDateLabel) return;
        if(!iso){
          $rankDateLabel.textContent = 'ğŸ“… ê¸°ì¤€ ë‚ ì§œ: ì‹œì¦Œ ì „ì²´ (2026-01-01 ~ 2026-06-30 ê¸°ì¤€)';
          return;
        }
        const parts = String(iso).split('-');
        if(parts.length===3){
          const [y,m,d] = parts;
          const mm = parseInt(m,10);
          const dd = parseInt(d,10);
          $rankDateLabel.textContent =
            `ğŸ“… ê¸°ì¤€ ë‚ ì§œ: ${y}ë…„ ${mm}ì›” ${dd}ì¼ (í•´ë‹¹ì¼ê¹Œì§€ì˜ ê²½ê¸°ë§Œ ë°˜ì˜)` +
            (noGames ? ' - ì„ íƒí•œ ë‚ ì§œê¹Œì§€ ê¸°ë¡ëœ ê²½ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤.' : '');
        } else {
          $rankDateLabel.textContent = `ğŸ“… ê¸°ì¤€ ë‚ ì§œ: ${iso}`;
        }
      }

      function recomputeRankingByDate(isoDate){
        if(!isoDate || !minRankDate){
          activeRows = baseRows;
          updateRankDateLabel(null,false);
          applyFilters();
          return;
        }

        if(isoDate < minRankDate){
          activeRows = [];
          updateRankDateLabel(isoDate,true);
          applyFilters();
          return;
        }

        const snapStat = new Map();
        const ensureSnap = (id)=>{
          if(snapStat.has(id)) return snapStat.get(id);
          const m = playersMeta.get(id) || {};
          const o = { id, elo:1000, tier:m.tier||'Silver', race:m.race||'Protoss', win:0, loss:0, played:0 };
          snapStat.set(id,o);
          return o;
        };

        for(const m of matchesForRanking){
          if(!m || !m.map || m.map==='Match') continue;
          const dIso = String(m.date);
          if(dIso > isoDate) break;

          if(m.player1 && m.player2){
            const p1=ensureSnap(m.player1), p2=ensureSnap(m.player2);
            if(m.winner===m.player1){ calc(p1,p2,1,false); p1.win++; p2.loss++; }
            else if(m.winner===m.player2){ calc(p1,p2,0,false); p2.win++; p1.loss++; }
            p1.played++; p2.played++;
          }

          if(Array.isArray(m.team1) && Array.isArray(m.team2)){
            const T1=m.team1.map(ensureSnap), T2=m.team2.map(ensureSnap);
            const winners = Array.isArray(m.winner)? m.winner : [];
            const win1 = winners.some(x=>m.team1.includes(x)) ? 1 : 0;

            const avg1=T1.reduce((a,b)=>a+b.elo,0)/T1.length;
            const avg2=T2.reduce((a,b)=>a+b.elo,0)/T2.length;
            const dA={elo:avg1,tier:'Silver'}, dB={elo:avg2,tier:'Silver'};
            calc(dA,dB,win1,true);
            const diffA=dA.elo-avg1, diffB=dB.elo-avg2;

            T1.forEach(p=>{ p.elo+=diffA; p.played++; win1?p.win++:p.loss++; });
            T2.forEach(p=>{ p.elo+=diffB; p.played++; !win1?p.win++:p.loss++; });
          }
        }

        activeRows = [...snapStat.values()]
          .filter(p=>!HIDE_IDS.has(p.id))
          .sort((a,b)=>b.elo-a.elo);

        updateRankDateLabel(isoDate,false);
        applyFilters();
      }

      ['input','change'].forEach(ev=>{
        $search.addEventListener(ev,applyFilters);
        $race.addEventListener(ev,applyFilters);
        $tier.addEventListener(ev,applyFilters);
      });

      if($rankDate){
        if(minRankDate) $rankDate.min = minRankDate;
        if(maxRankDate) $rankDate.max = maxRankDate;
        $rankDate.addEventListener('change', ()=>{
          const v = $rankDate.value;
          recomputeRankingByDate(v || null);
        });
      }

      updateRankDateLabel(null,false);
      applyFilters();

      // --- Old Records (ì™„ë£Œëœ ì‹œì¦Œ) ---
      (function buildOldRecords(){
        const tabsEl = document.getElementById('oldSeasonTabs');
        const contentEl = document.getElementById('oldSeasonContent');
        if(!tabsEl || !contentEl) return;

        // í˜„ì¬ ì‹œì¦Œ ì‹œì‘ ì´ì „ì— ëë‚œ ì‹œì¦Œë§Œ Old Records ëŒ€ìƒ
        const currentStart = CURRENT_SEASON.start;
        const archivedSeasons = SEASONS.filter(s=>{
          if(s.key === CURRENT_SEASON_KEY) return false;
          if(!currentStart) return false;
          if(!s.end) return false;
          return s.end < currentStart;
        });

        if(!archivedSeasons.length){
          tabsEl.innerHTML = '<div class="muted">ì•„ì§ ì´ì „ ì‹œì¦Œ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
          contentEl.innerHTML = '';
          return;
        }

        const seasonRankings = {};

        function computeSeasonRanking(season){
          const st = new Map();

            // âœ… ì´ ì‹œì¦Œì— í•´ë‹¹í•˜ëŠ” í‹°ì–´ ìŠ¤ëƒ…ìƒ· (ì—†ìœ¼ë©´ ë¹ˆ ê°ì²´)
          const seasonTierMap = SEASON_TIER_SNAPSHOT[season.key] || {};
          const ensureS = (id)=>{
            if (st.has(id)) return st.get(id);
          const m = playersMeta.get(id) || {};
            
    // ìŠ¤ëƒ…ìƒ·ì— ê°’ì´ ìˆìœ¼ë©´ ê·¸ í‹°ì–´ë¥¼ ìš°ì„  ì‚¬ìš©,
    // ì—†ìœ¼ë©´ í˜„ì¬ data.jsonì˜ tier ì‚¬ìš© (ì˜ˆ: ìƒˆë¡œ í•©ë¥˜í•œ ì‚¬ëŒ ë“±)
            const snapshotTier = seasonTierMap[id];
            const tier = snapshotTier || m.tier || 'Silver';
            const o = { id, elo:1000, tier, race:m.race || 'Protoss', win:0, loss:0, played:0 };
            st.set(id, o);
            return o;
          };

          for(const m of matchesAll){
            if(!isInSeason(m, season)) continue;
            if(!m || !m.map || m.map==='Match') continue;

            if(m.player1 && m.player2){
              const p1=ensureS(m.player1), p2=ensureS(m.player2);
              if(m.winner===m.player1){ calc(p1,p2,1,false); p1.win++; p2.loss++; }
              else if(m.winner===m.player2){ calc(p1,p2,0,false); p2.win++; p1.loss++; }
              p1.played++; p2.played++;
            }

            if(Array.isArray(m.team1) && Array.isArray(m.team2)){
              const T1=m.team1.map(ensureS), T2=m.team2.map(ensureS);
              const winners = Array.isArray(m.winner)? m.winner : [];
              const win1 = winners.some(x=>m.team1.includes(x)) ? 1 : 0;

              const avg1=T1.reduce((a,b)=>a+b.elo,0)/T1.length;
              const avg2=T2.reduce((a,b)=>a+b.elo,0)/T2.length;
              const dA={elo:avg1,tier:'Silver'}, dB={elo:avg2,tier:'Silver'};
              calc(dA,dB,win1,true);
              const diffA=dA.elo-avg1, diffB=dB.elo-avg2;

              T1.forEach(p=>{ p.elo+=diffA; p.played++; win1?p.win++:p.loss++; });
              T2.forEach(p=>{ p.elo+=diffB; p.played++; !win1?p.win++:p.loss++; });
            }
          }

          return [...st.values()]
            .filter(p=>!HIDE_IDS.has(p.id))
            .sort((a,b)=>b.elo-a.elo);
        }

        archivedSeasons.forEach(s=>{
          seasonRankings[s.key] = computeSeasonRanking(s);
        });

        tabsEl.innerHTML = archivedSeasons.map((s,i)=>`
          <button class="old-season-tab ${i===0?'active':''}"
            data-season="${s.key}"
            style="background:#1a1a22;border:1px solid #232532;color:#ddd;padding:8px 12px;border-radius:10px;cursor:pointer;">
            ${escapeHtml(s.label)}
          </button>
        `).join(' ');

        function renderSeason(key){
          const season = archivedSeasons.find(s=>s.key===key);
          const rows = seasonRankings[key] || [];
          if(!season){
            contentEl.innerHTML = '';
            return;
          }
          if(!rows.length){
            contentEl.innerHTML = `<div class="muted">${escapeHtml(season.label)} ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
            return;
          }

          const bodyHtml = rows.map((p,i)=>{
            const wr = p.played ? ((p.win/p.played)*100).toFixed(1) : '0.0';
            return `
              <tr>
                <td>${i+1}</td>
                <td>${escapeHtml(p.id)}</td>
                <td>${p.race}</td>
                <td class="tier-${p.tier}">${p.tier}</td>
                <td>${Math.round(p.elo)}</td>
                <td>${p.win}</td>
                <td>${p.loss}</td>
                <td>${wr}%</td>
              </tr>
            `;
          }).join('');

          const rangeText =
            (season.start ? season.start : 'ì‹œì‘ì¼ ë¯¸ì •')
            + ' ~ ' +
            (season.end   ? season.end   : 'ì¢…ë£Œì¼ ë¯¸ì •');

           contentEl.innerHTML = `
            <div class="muted" style="font-size:12px;margin-bottom:6px;">
              ì‹œì¦Œ ê¸°ê°„: ${rangeText}
            </div>
              <div class="old-records-wrap" style="max-height:660px;overflow-y:auto;border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:6px;">
               <table class="old-records-table" style="width:100%;border-collapse:collapse;">
                <thead>
                  <tr>
                    <th>Rank</th><th>ID</th><th>ì¢…ì¡±</th><th>í‹°ì–´</th><th>ELO</th><th>ìŠ¹</th><th>íŒ¨</th><th>ìŠ¹ë¥ </th>
                  </tr>
                </thead>
                <tbody>
                  ${bodyHtml}
                </tbody>
              </table>
            </div>
          `;
        }

        // ì´ˆê¸° í‘œì‹œ (ì²« ì‹œì¦Œ)
        renderSeason(archivedSeasons[0].key);

        tabsEl.addEventListener('click', e=>{
          const btn = e.target.closest('.old-season-tab');
          if(!btn) return;
          tabsEl.querySelectorAll('.old-season-tab').forEach(b=>b.classList.remove('active'));
          btn.classList.add('active');
          renderSeason(btn.dataset.season);
        });
      })();

      // --- ê¸°ë¡ì‹¤ (ì›”ë³„ íƒ­) ---
      const list = document.getElementById('match-list');
      const tabsWrap = document.getElementById('records-months');

      const getMonthKey = (iso) => {
        if(!iso || !iso.includes('-')) return 'unknown';
        const [y,m] = iso.split('-');
        return `${y}-${m}`;
      };
      const getMonthLabel = (key) => {
        const [y,m] = key.split('-');
        const yy = String(y).slice(2);
        const mm = String(parseInt(m,10));
        return `${yy}ë…„ ${mm}ì›”`;
      };

      const byMonth = new Map();
      for (const m of matchesAll) {
        const key = getMonthKey(m.date);
        if (!byMonth.has(key)) byMonth.set(key, []);
        byMonth.get(key).push(m);
      }
      const monthsSorted = [...byMonth.keys()].sort((a,b)=> a.localeCompare(b));

      tabsWrap.innerHTML = monthsSorted.map((key,i)=>`
        <button class="month-tab${i===monthsSorted.length-1?' active':''}"
          data-month="${key}"
          style="background:#1a1a22;border:1px solid #232532;color:#ddd;padding:8px 12px;border-radius:10px;cursor:pointer;">
          ${getMonthLabel(key)}
        </button>
      `).join(' ');

      function renderMonth(key){
        const dataM = (byMonth.get(key)||[]).slice().sort((a,b)=> String(a.date).localeCompare(String(b.date)));
        list.innerHTML = '';

        let curDate=null, box=null, mCount=0;
        const flushHeader = ()=>{ if(box && mCount>0){ box.querySelector('.match-header').textContent += ` (Match ${mCount}ê²Œì„)`; } };

        for(const m of dataM){
          if(m.date !== curDate){
            flushHeader();
            curDate = m.date; mCount = 0;

            box = document.createElement('div');
            box.className = 'match';

            const hdr = document.createElement('div');
            hdr.className = 'match-header';
            hdr.textContent = `${curDate}`;

            const inner = document.createElement('div');
            inner.className = 'match-inner hidden';
            hdr.addEventListener('click',()=> inner.classList.toggle('hidden'));

            box.appendChild(hdr);
            box.appendChild(inner);
            list.appendChild(box);
          }

          const wrap = box.querySelector('.match-inner');

          if(m.map === 'Match'){
            mCount++;
            const line = document.createElement('div');
            line.className = 'match-item';
            line.style.color = '#a8e0a8';
            const win = Array.isArray(m.winner)? m.winner.join(', ') : (m.winner||'-');
            line.textContent = `[Match] ìŠ¹ì: ${win}${m.score?` | ìŠ¤ì½”ì–´: ${m.score}`:''}`;
            wrap.appendChild(line);
            continue;
          }

          if(m.player1 && m.player2){
            const l = document.createElement('div'); l.className='match-item';
            l.textContent = `${m.map||'-'} â€” ${m.player1} vs ${m.player2} | ìŠ¹ì: ${m.winner||'-'}${m.score?` | ${m.score}`:''}`;
            wrap.appendChild(l);
          }

          if(Array.isArray(m.team1) && Array.isArray(m.team2)){
            const l = document.createElement('div'); l.className='match-item';
            const win = Array.isArray(m.winner)? m.winner.join(', ') : (m.winner||'-');
            l.textContent = `${m.map||'-'} â€” [${m.team1.join(', ')}] vs [${m.team2.join(', ')}] | ìŠ¹ì: ${win}${m.score?` | ${m.score}`:''}`;
            wrap.appendChild(l);
          }
        }
        flushHeader();
      }

      if (monthsSorted.length){
        renderMonth(monthsSorted[monthsSorted.length-1]);
      }

      tabsWrap.addEventListener('click', (e)=>{
        const btn = e.target.closest('.month-tab');
        if(!btn) return;
        tabsWrap.querySelectorAll('.month-tab').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        renderMonth(btn.dataset.month);
      });

      // --- ìƒëŒ€ ì „ì  ì¡°íšŒ ---
      renderHeadToHead(data, matchesAll, playersMeta);
    }

    // ===== ìƒëŒ€ ì „ì  ì¡°íšŒ êµ¬í˜„ =====
    function renderHeadToHead(data, matches, playersMeta){
      const $p1 = document.getElementById('h2hP1');
      const $p2 = document.getElementById('h2hP2');
      const $btn = document.getElementById('h2hSearchBtn');
      const $clr = document.getElementById('h2hClearBtn');
      const $out = document.getElementById('h2hResult');

      if(!$p1 || !$p2 || !$btn || !$out) return;

      const HIDE = new Set(['Wonder','ceta']);

      const ids = [...new Set([
        ...(data.players||[]).map(p=>p.id),
        ...matches.flatMap(m=>{
          const a=[];
          if(m.player1) a.push(m.player1);
          if(m.player2) a.push(m.player2);
          if(Array.isArray(m.team1)) a.push(...m.team1);
          if(Array.isArray(m.team2)) a.push(...m.team2);
          return a;
        })
      ])].filter(Boolean).filter(id=>!HIDE.has(id)).sort((a,b)=>a.localeCompare(b));

      function fillSelectOptions(){
        const prev1 = $p1.value || '';
        const prev2 = $p2.value || '';

        $p1.innerHTML =
          `<option value="">Player#1 ì„ íƒ (í•„ìˆ˜)</option>` +
          ids.map(id => `<option value="${escapeHtml(id)}">${escapeHtml(id)}</option>`).join('');

        $p2.innerHTML =
          `<option value="">Player#2 ì„ íƒ (ì„ íƒ)</option>` +
          ids.map(id => `<option value="${escapeHtml(id)}">${escapeHtml(id)}</option>`).join('');

        if(prev1 && ids.includes(prev1)) $p1.value = prev1;
        if(prev2 && ids.includes(prev2)) $p2.value = prev2;
      }
      fillSelectOptions();

      function normalizeId(v){ return (v||'').trim(); }
      function pct(w,l){ const n=w+l; return n? ((w/n)*100).toFixed(1) : '0.0'; }

      function computePair(p1, p2){
        let soloW=0, soloL=0, teamW=0, teamL=0;
        const soloDetails=[];
        const teamDetails=[];

        for(const m of matches){
          if(!m || !m.map) continue;
          if(m.map === 'Match') continue;

          if(m.player1 && m.player2){
            const a=m.player1, b=m.player2;
            if(!((a===p1 && b===p2) || (a===p2 && b===p1))) continue;
            const winner=m.winner||'';
            const p1Win = (winner===p1);
            const p2Win = (winner===p2);
            if(!p1Win && !p2Win) continue;

            if(p1Win) soloW++; else soloL++;
            soloDetails.push({
              date: m.date||'-',
              map: m.map||'-',
              score: m.score||'',
              result: p1Win ? 'ìŠ¹' : 'íŒ¨',
              opponent: p2
            });
            continue;
          }

          if(Array.isArray(m.team1) && Array.isArray(m.team2)){
            const t1=m.team1, t2=m.team2;
            const p1In1=t1.includes(p1), p1In2=t2.includes(p1);
            const p2In1=t1.includes(p2), p2In2=t2.includes(p2);

            if((p1In1 && p2In1) || (p1In2 && p2In2)) continue;

            const opposed = (p1In1 && p2In2) || (p1In2 && p2In1);
            if(!opposed) continue;

            const winners = Array.isArray(m.winner) ? m.winner : [];
            const win1 = winners.some(x=>t1.includes(x)) ? 1 : 0;
            const p1Win = p1In1 ? !!win1 : !win1;

            if(p1Win) teamW++; else teamL++;

            teamDetails.push({
              date: m.date||'-',
              map: m.map||'-',
              score: m.score||'',
              result: p1Win ? 'ìŠ¹' : 'íŒ¨',
              myTeam: p1In1 ? t1.slice() : t2.slice(),
              oppTeam: p1In1 ? t2.slice() : t1.slice(),
              opponent: p2
            });
            continue;
          }
        }

        return {
          p1, p2,
          soloW, soloL,
          teamW, teamL,
          soloDetails,
          teamDetails
        };
      }

      function listOpponents(p1){
        const opp = new Map();
        const bump = (id, key)=>{
          if(!id || id===p1) return;
          if(HIDE.has(id)) return;
          if(!opp.has(id)) opp.set(id,{id, solo:0, team:0});
          opp.get(id)[key]++;
        };

        for(const m of matches){
          if(!m || !m.map) continue;
          if(m.map === 'Match') continue;

          if(m.player1 && m.player2){
            const a=m.player1, b=m.player2;
            if(a===p1) bump(b,'solo');
            if(b===p1) bump(a,'solo');
          }

          if(Array.isArray(m.team1) && Array.isArray(m.team2)){
            const t1=m.team1, t2=m.team2;
            const in1=t1.includes(p1), in2=t2.includes(p1);
            if(!in1 && !in2) continue;
            const other = in1 ? t2 : t1;
            for(const o of other) bump(o,'team');
          }
        }

        const arr=[...opp.values()].map(o=>({ ...o, total:o.solo+o.team }));
        arr.sort((a,b)=> b.total-a.total || a.id.localeCompare(b.id));
        return arr;
      }

      function renderDetailList(title, items, mode){
        if(!items || !items.length){
          return `<div class="muted">${title}: ë°ì´í„° ì—†ìŒ</div>`;
        }
        const rows = items
          .slice()
          .sort((a,b)=> String(a.date).localeCompare(String(b.date)))
          .map(it=>{
            const color = (it.result==='ìŠ¹') ? '#4ade80' : '#f87171';
            const score = it.score ? ` | ${escapeHtml(it.score)}` : '';
            if(mode==='solo'){
              return `<div style="margin:4px 0;color:#ddd">
                ${escapeHtml(it.date)} | ${escapeHtml(it.map)} | <b style="color:${color}">${it.result}</b>${score}
              </div>`;
            }
            return `<div style="margin:4px 0;color:#ddd">
              ${escapeHtml(it.date)} | ${escapeHtml(it.map)} | <b style="color:${color}">${it.result}</b>${score}
              "font-size:12px;margin-left:10px">
                ìš°ë¦¬íŒ€: [${(it.myTeam||[]).map(escapeHtml).join(', ')}] / ìƒëŒ€íŒ€: [${(it.oppTeam||[]).map(escapeHtml).join(', ')}]
              </div>
            </div>`;
          }).join('');
        return `<div style="font-weight:700;color:#ffb347;margin-bottom:6px">${title}</div>${rows}`;
      }

      function renderPairResult(pair){
        const {p1,p2,soloW,soloL,teamW,teamL,soloDetails,teamDetails} = pair;
        const soloN=soloW+soloL, teamN=teamW+teamL;

        const soloWr=pct(soloW,soloL);
        const teamWr=pct(teamW,teamL);

        const html = `
          <div class="card" style="margin-top:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
              <div style="font-weight:800;color:#ffb347">${escapeHtml(p1)} vs ${escapeHtml(p2)}</div>
              "font-size:12px">ê°œì¸ì „/íŒ€ì „ ë¶„ë¦¬ ì§‘ê³„</div>
            </div>

            <table style="margin-top:10px">
              <thead>
                <tr>
                  <th>êµ¬ë¶„</th><th>ìŠ¹</th><th>íŒ¨</th><th>ìŠ¹ë¥ </th><th>ê²Œì„ìˆ˜</th><th>ìƒì„¸</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>ê°œì¸ì „</td>
                  <td>${soloW}</td><td>${soloL}</td><td>${soloWr}%</td><td>${soloN}</td>
                  <td style="text-align:center">
                    <button class="h2h-toggle" data-target="solo"
                      style="border:1px solid #232532;background:#1a1a22;color:#ddd;border-radius:8px;padding:6px 10px;cursor:pointer">
                      â–¼
                    </button>
                  </td>
                </tr>
                <tr>
                  <td>íŒ€ì „</td>
                  <td>${teamW}</td><td>${teamL}</td><td>${teamWr}%</td><td>${teamN}</td>
                  <td style="text-align:center">
                    <button class="h2h-toggle" data-target="team"
                      style="border:1px solid #232532;background:#1a1a22;color:#ddd;border-radius:8px;padding:6px 10px;cursor:pointer">
                      â–¼
                    </button>
                  </td>
                </tr>
              </tbody>
            </table>

            <div id="h2hDetailSolo" class="hidden" style="margin-top:10px;border-top:1px solid rgba(255,255,255,0.06);padding-top:10px">
              ${renderDetailList('ê°œì¸ì „ ìƒì„¸', soloDetails, 'solo')}
            </div>

            <div id="h2hDetailTeam" class="hidden" style="margin-top:10px;border-top:1px solid rgba(255,255,255,0.06);padding-top:10px">
              ${renderDetailList('íŒ€ì „ ìƒì„¸', teamDetails, 'team')}
            </div>
          </div>
        `;
        return html;
      }

      function renderOpponentList(p1){
        const opponents = listOpponents(p1);
        if(!opponents.length){
          $out.innerHTML = `<div class="muted">ìƒëŒ€ ì „ì ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
          return;
        }

        const listHtml = `
          <div class="card" style="margin-top:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
              <div style="font-weight:800;color:#ffb347">${escapeHtml(p1)} ìƒëŒ€ ëª©ë¡</div>
              "font-size:12px">í´ë¦­í•˜ë©´ ì•„ë˜ì— ì „ì ì´ í‘œì‹œë©ë‹ˆë‹¤.</div>
            </div>

            <table style="margin-top:10px">
              <thead>
                <tr><th>ìƒëŒ€ ID</th><th>ê°œì¸ì „ ê²Œì„</th><th>íŒ€ì „ ê²Œì„</th><th>ì´ ê²Œì„</th><th>ì„ íƒ</th></tr>
              </thead>
              <tbody>
                ${opponents.map(o=>`
                  <tr>
                    <td>${escapeHtml(o.id)}</td>
                    <td>${o.solo}</td>
                    <td>${o.team}</td>
                    <td>${o.total}</td>
                    <td>
                      <button class="h2h-pick" data-opp="${escapeHtml(o.id)}"
                        style="border:1px solid #232532;background:#1a1a22;color:#ddd;border-radius:8px;padding:6px 10px;cursor:pointer">
                        ì„ íƒ
                      </button>
                    </td>
                  </tr>
                `).join('')}
              </tbody>
            </table>

            <div id="h2hPickedArea" style="margin-top:12px"></div>
          </div>
        `;
        $out.innerHTML = listHtml;

        const picked = document.getElementById('h2hPickedArea');
        $out.querySelectorAll('.h2h-pick').forEach(btn=>{
          btn.addEventListener('click', ()=>{
            const oppId = btn.dataset.opp;
            $p2.value = oppId;
            const pair = computePair(p1, oppId);
            picked.innerHTML = renderPairResult(pair);
            bindPairToggles(picked);
          });
        });
      }

      function bindPairToggles(root){
        root.querySelectorAll('.h2h-toggle').forEach(btn=>{
          btn.addEventListener('click', ()=>{
            const t = btn.dataset.target;
            const soloEl = root.querySelector('#h2hDetailSolo');
            const teamEl = root.querySelector('#h2hDetailTeam');
            if(t==='solo' && soloEl) soloEl.classList.toggle('hidden');
            if(t==='team' && teamEl) teamEl.classList.toggle('hidden');
          });
        });
      }

      function doSearch(){
        const p1 = normalizeId($p1.value);
        const p2 = normalizeId($p2.value);

        if(!p1){
          $out.innerHTML = `<div class="muted">Player#1 IDë¥¼ ì„ íƒí•˜ì„¸ìš”.</div>`;
          return;
        }
        if(HIDE.has(p1) || (p2 && HIDE.has(p2))){
          $out.innerHTML = `<div class="muted">í•´ë‹¹ IDëŠ” ì¡°íšŒ ëŒ€ìƒì—ì„œ ì œì™¸ë˜ì–´ ìˆìŠµë‹ˆë‹¤.</div>`;
          return;
        }
        if(p2 && p1===p2){
          $out.innerHTML = `<div class="muted">Player#1ê³¼ Player#2ëŠ” ì„œë¡œ ë‹¤ë¥¸ IDì—¬ì•¼ í•©ë‹ˆë‹¤.</div>`;
          return;
        }

        const known = new Set(ids);
        if(!known.has(p1)){
          $out.innerHTML = `<div class="muted">Player#1(${escapeHtml(p1)})ì„ ë°ì´í„°ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</div>`;
          return;
        }
        if(p2 && !known.has(p2)){
          $out.innerHTML = `<div class="muted">Player#2(${escapeHtml(p2)})ì„ ë°ì´í„°ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</div>`;
          return;
        }

        if(!p2){
          renderOpponentList(p1);
          return;
        }

        const pair = computePair(p1,p2);
        $out.innerHTML = renderPairResult(pair);
        bindPairToggles($out);
      }

      $btn.addEventListener('click', doSearch);
      $clr.addEventListener('click', ()=>{
        $p1.value=''; $p2.value='';
        $out.innerHTML = `<div class="muted">Player#1 / Player#2ë¥¼ ì„ íƒ í›„ ì¡°íšŒí•˜ì„¸ìš”.</div>`;
      });

      $out.innerHTML = `<div class="muted">Player#1 / Player#2ë¥¼ ì„ íƒ í›„ ì¡°íšŒí•˜ì„¸ìš”.</div>`;
    }

    function escapeHtml(s){
      return String(s??'')
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'","&#39;");
    }

    // --- (í˜„ì¬ëŠ” ë¯¸ì‚¬ìš©) Recharts ê·¸ë˜í”„ìš© í•¨ìˆ˜: í•„ìš”í•˜ë©´ ì¶”í›„ í™œì„±í™” ---
    function renderChart(eloByDate){
      const container=document.getElementById('elo-chart-container');
      if(!container) return;

      const HIDE = new Set(['Wonder', 'ceta']);

      container.innerHTML = `
        <div style="display:flex;gap:16px;align-items:flex-start;flex-wrap:wrap;">
          <div>
            <div style="font-size:13px;color:#aaa;margin-bottom:6px">ë¹„êµí•  í”Œë ˆì´ì–´ ì„ íƒ (Ctrl/âŒ˜ ë‹¤ì¤‘ ì„ íƒ)</div>
            <select id="eloPlayerSelect" multiple size="10"
              style="min-width:220px;height:200px;padding:10px;border-radius:8px;border:1px solid #2c2f3a;background:#101018;color:#fff;">
              ${Object.keys(eloByDate)
                  .filter(id => !HIDE.has(id))
                  .sort()
                  .map(id => `<option value="${id}">${id}</option>`)
                  .join('')}
              </select>
            </div>
            <div id="eloChartArea" style="flex:1;min-width:320px;width:100%;height:460px"></div>
          </div>
        `;

      const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } = window.Recharts || {};
      const area = document.getElementById('eloChartArea');
      if(!LineChart){ area.innerHTML=`<div class="muted">Rechartsê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</div>`; return; }

      const palette=["#ff6a00","#4ade80","#60a5fa","#f472b6","#facc15","#38bdf8","#a78bfa","#fb923c","#22d3ee","#94a3b8"];

      function draw(sel){
        if(!sel.length){ area.innerHTML=`<div class="muted">ì™¼ìª½ì—ì„œ 1ëª… ì´ìƒ ì„ íƒí•˜ì„¸ìš”.</div>`; return; }
        const dates=[...new Set(sel.flatMap(id=>Object.keys(eloByDate[id]||{})))].sort((a,b)=>{
          const [am,ad]=a.split('/').map(Number), [bm,bd]=b.split('/').map(Number);
          return am===bm? ad-bd : am-bm;
        });
        const rows=dates.map(d=>{ const r={date:d}; sel.forEach(id=>r[id]=eloByDate[id]?.[d]??null); return r; });

        ReactDOM.render(
          React.createElement(
            ResponsiveContainer,{width:"100%",height:460},
            React.createElement(LineChart,{data:rows,margin:{top:20,right:30,left:0,bottom:0}},
              React.createElement(CartesianGrid,{strokeDasharray:"3 3",stroke:"rgba(255,255,255,0.12)"}),
              React.createElement(XAxis,{dataKey:"date",stroke:"#aaa",tick:{fontSize:12}}),
              React.createElement(YAxis,{stroke:"#aaa",domain:[800,1200],tick:{fontSize:12}}),
              React.createElement(Tooltip,{formatter:v=>Math.round(v),contentStyle:{backgroundColor:"#1a1a22",border:"1px solid #333"}}),
              React.createElement(Legend,null),
              ...sel.map((id,i)=>React.createElement(Line,{
                key:id, type:"monotone", dataKey:id, name:id,
                stroke:palette[i%palette.length], dot:false, strokeWidth:2, isAnimationActive:false
              }))
            )
          ), area
        );
      }

      document.getElementById('eloPlayerSelect').addEventListener('change', e=>{
        const sel=[...e.target.selectedOptions].map(o=>o.value);
        draw(sel);
      });
    }

    // --- íŒì—… ë¡œì§: í”Œë ˆì´ì–´ í´ë¦­ ì‹œ ìƒì„¸ ---
    const tbody = document.querySelector('#players-table tbody');
    if(tbody){
      tbody.addEventListener('click', async e=>{
        const tr = e.target.closest('tr');
        if(!tr) return;
        const playerId = tr.children[1]?.textContent.trim();
        if(!playerId) return;
        await showPlayerModal(playerId, CURRENT_SEASON_KEY);
      });
    }
    
// âœ… Old Records í…Œì´ë¸”ì—ì„œë„ ID í´ë¦­ ì‹œ íŒì—… ì—´ê¸°
const oldContent = document.getElementById('oldSeasonContent');
if(oldContent){
  oldContent.addEventListener('click', async e=>{
    const cell = e.target.closest('td');
    if(!cell) return;

    const row = cell.parentElement;
    const table = row.closest('table');
    if(!table || !table.classList.contains('old-records-table')) return;

    // Old Records ì»¬ëŸ¼ ìˆœì„œ: Rank, ID, ì¢…ì¡±, í‹°ì–´, ELO, ìŠ¹, íŒ¨, ìŠ¹ë¥ 
    const colIndex = Array.from(row.children).indexOf(cell);
    if(colIndex !== 1) return; // ID ì»¬ëŸ¼(ë‘ ë²ˆì§¸ ì¹¸)ì´ ì•„ë‹ ë•Œ ë¬´ì‹œ

    const playerId = (cell.textContent || '').trim();
    if(!playerId) return;
    const activeBtn = document.querySelector('#oldSeasonTabs .old-season-tab.active');
    const seasonKey = activeBtn?.dataset?.season || '2025'; // fallback
    await showPlayerModal(playerId, seasonKey);
  });
}

async function showPlayerModal(playerId, seasonKey=CURRENT_SEASON_KEY){
  try{
    const base = await safe(path('data.json'));
    const months = ['oct','nov','dec','jan'];
    for(const m of months){
      const add = await safe(path(`data_${m}.json`));
      base.matches = (base.matches||[]).concat(add.matches||[]);
      const seen = new Set((base.players||[]).map(p=>p.id));
      (add.players||[]).forEach(p=>{ if(!seen.has(p.id)) base.players.push(p); });
    }

    const season = SEASONS.find(s=>s.key===seasonKey) || CURRENT_SEASON;
    const seasonTierMap = SEASON_TIER_SNAPSHOT[seasonKey] || {};

    const player = base.players.find(p=>p.id===playerId);
    if(!player){ alert('í”Œë ˆì´ì–´ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }

    const TierOrder=['Stone','Bronze','Silver','Gold','Diamond','Legend'];
    const getTierIndex=t=>Math.max(0,TierOrder.indexOf(t||'Silver'));
    const calc=(A,B,res,isTeam)=>{
      const K=isTeam?8:12;
      const effA=A.elo+getTierIndex(A.tier)*40;
      const effB=B.elo+getTierIndex(B.tier)*40;
      const expectedA=1/(1+Math.pow(10,(effB-effA)/400));
      const delta=K*(res-expectedA);
      A.elo+=delta; B.elo-=delta;
    };

    const stat=new Map();
    const ensure=(id)=>{
      if(stat.has(id)) return stat.get(id);
      const meta=(base.players||[]).find(p=>p.id===id)||{};
      const fixedTier = seasonTierMap[id] || meta.tier || 'Silver'; // âœ… ì‹œì¦Œ ìŠ¤ëƒ…ìƒ· ìš°ì„ 
      const o={id,tier:fixedTier,race:meta.race||'Protoss',elo:1000,history:[1000]};
      stat.set(id,o); return o;
    };

    const matches=(base.matches||[])
      .filter(m=>m && m.map!=="Match" && isInSeason(m, season)) // âœ… ì‹œì¦Œ í•„í„°
      .slice()
      .sort((a,b)=>String(a.date).localeCompare(String(b.date)));

    const playerLog=[];
    for(const m of matches){
      if(m.player1 && m.player2){
        const p1=ensure(m.player1), p2=ensure(m.player2);
        const res=(m.winner===m.player1)?1:(m.winner===m.player2)?0:null;
        let involved=false, eloBefore=0, opponentText='';
        if(m.player1===playerId){ involved=true; eloBefore=p1.elo; opponentText=m.player2; }
        else if(m.player2===playerId){ involved=true; eloBefore=p2.elo; opponentText=m.player1; }
        if(res!==null){ calc(p1,p2,res,false); p1.history.push(Math.round(p1.elo)); p2.history.push(Math.round(p2.elo)); }
        if(involved){
          const after=(m.player1===playerId)?p1.elo:p2.elo;
          const isWin=(m.winner===playerId);
          playerLog.push({date:m.date,map:m.map||'-',opponentText,isWin,eloAfter:Math.round(after),delta:Math.round(after-eloBefore)});
        }
      }

      if(Array.isArray(m.team1)&&Array.isArray(m.team2)){
        const T1=m.team1.map(ensure), T2=m.team2.map(ensure);
        const winners=Array.isArray(m.winner)?m.winner:[];
        const win1=winners.some(x=>m.team1.includes(x))?1:0;

        const avg1=T1.reduce((a,b)=>a+b.elo,0)/T1.length;
        const avg2=T2.reduce((a,b)=>a+b.elo,0)/T2.length;
        const dA={elo:avg1,tier:'Silver'}, dB={elo:avg2,tier:'Silver'};
        calc(dA,dB,win1,true);
        const diffA=dA.elo-avg1, diffB=dB.elo-avg2;

        T1.forEach(p=>{ const before=p.elo; p.elo+=diffA; p.history.push(Math.round(p.elo));
          if(p.id===playerId) playerLog.push({date:m.date,map:m.map||'-',opponentText:`íŒ€ì „ vs ${m.team2.join(',')}`,isWin:!!win1,eloAfter:Math.round(p.elo),delta:Math.round(p.elo-before)});
        });
        T2.forEach(p=>{ const before=p.elo; p.elo+=diffB; p.history.push(Math.round(p.elo));
          if(p.id===playerId) playerLog.push({date:m.date,map:m.map||'-',opponentText:`íŒ€ì „ vs ${m.team1.join(',')}`,isWin:!win1,eloAfter:Math.round(p.elo),delta:Math.round(p.elo-before)});
        });
      }
    }

        const target=stat.get(playerId);
        if(!target){ alert('ê²½ê¸° ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.'); return; }

        document.getElementById('modalPlayerName').textContent=player.id;
        document.getElementById('modalPlayerInfo').innerHTML=
          `<b>Race:</b> ${player.race} | <b>Tier:</b> ${player.tier} | <b>í˜„ì¬ ELO:</b> ${Math.round(target.elo)} (${target.history.length-1}ê²½ê¸°)`;

        let soloWin=0, soloLoss=0, teamWin=0, teamLoss=0;
        let scWin=0, scLoss=0, htWin=0, htLoss=0;
        let proWin=0, proLoss=0;
        const proLog = [];

        for (const m of base.matches || []) {
          if (!isInSeason(m, season)) continue; // âœ… ì„ íƒëœ ì‹œì¦Œ(í˜„ì¬/Old Records ëª¨ë‘) ê¸°ì¤€ìœ¼ë¡œ ìŠ¤í‚µ

          const isSolo = !!(m.player1 && m.player2);
          const isTeam = Array.isArray(m.team1) && Array.isArray(m.team2);
          const isSC = (m.map||'').includes('ìƒì»¨');
          const isHT = (m.map||'').includes('í—Œí„°');

          if (m.map === "Match" && Array.isArray(m.team1) && Array.isArray(m.team2)) {
            const inT1 = m.team1.includes(playerId);
            const inT2 = m.team2.includes(playerId);
            if (!inT1 && !inT2) continue;

            const winners = Array.isArray(m.winner) ? m.winner : [];
            const win1 = winners.some(x => m.team1.includes(x)) ? 1 : 0;
            const isWin = inT1 ? !!win1 : !win1;
            isWin ? proWin++ : proLoss++;

            proLog.push({
              isWin,
              date: m.date || '-',
              map: m.map || '-',
              score: m.score || ''
            });
            continue;
          }

          if (isSolo && (m.player1===playerId || m.player2===playerId)) {
            const isWin = (m.winner===playerId);
            isWin ? soloWin++ : soloLoss++;
            if (isSC) (isWin ? scWin++ : scLoss++);
            if (isHT) (isWin ? htWin++ : htLoss++);
          }

          if (isTeam && ((m.team1||[]).includes(playerId) || (m.team2||[]).includes(playerId))) {
            const isTeam1 = m.team1.includes(playerId);
            const winners = Array.isArray(m.winner) ? m.winner : [];
            const win1 = winners.some(x => m.team1.includes(x)) ? 1 : 0;
            const isWin = isTeam1 ? !!win1 : !win1;
            isWin ? teamWin++ : teamLoss++;
            if (isSC) (isWin ? scWin++ : scLoss++);
            if (isHT) (isWin ? htWin++ : htLoss++);
          }
        }

        let statsEl = document.getElementById('modalStats');
        if (!statsEl) {
          statsEl = document.createElement('div');
          statsEl.id = 'modalStats';
          statsEl.style.margin = '10px 0 14px 0';
          statsEl.style.color = '#ccc';
          statsEl.style.fontSize = '14px';
          const infoEl = document.getElementById('modalPlayerInfo');
          infoEl.insertAdjacentElement('afterend', statsEl);
        }

        let recentStreakText = '';
        if (proLog.length) {
          const recent = proLog.slice(-10);
          const seq = recent.map(g => g.isWin ? 'ìŠ¹' : 'íŒ¨').join(' ');
          recentStreakText = ` <span style="color:#ffb347;font-size:13px;">(ìµœê·¼ ${recent.length}ê²½ê¸°: ${seq})</span>`;
        }

        statsEl.innerHTML = `
          <div>
            ğŸ† <b>í”„ë¡œë¦¬ê·¸:</b> ${proWin}ìŠ¹ ${proLoss}íŒ¨${recentStreakText}<br>
            <b>ê°œì¸ì „:</b> ${soloWin}ìŠ¹ ${soloLoss}íŒ¨,
            <b>íŒ€ì „:</b> ${teamWin}ìŠ¹ ${teamLoss}íŒ¨
            <span style="color:#888">(íŒ€ì „ì€ ìƒì»¨Â·í—Œí„° ëª¨ë‘ í¬í•¨)</span><br>
            <b>ìƒì»¨:</b> ${scWin}ìŠ¹ ${scLoss}íŒ¨,
            <b>í—Œí„°:</b> ${htWin}ìŠ¹ ${htLoss}íŒ¨
          </div>
        `;

        const ctx=document.getElementById('modalEloChart').getContext('2d');
        if(window.modalChart)window.modalChart.destroy();
        window.modalChart=new Chart(ctx,{
          type:'line',
          data:{
            labels:target.history.map((_,i)=>i),
            datasets:[{label:'ELO',data:target.history,borderColor:'#ff6a00',borderWidth:2,fill:false,tension:0.3}]
          },
          options:{
            plugins:{legend:{display:false}},
            scales:{
              x:{ticks:{color:'#ccc'}},
              y:{ticks:{color:'#ccc'}}
            }
          }
        });

        document.getElementById('modalMatchHistory').innerHTML =
          (playerLog.length? playerLog : []).map(row=>{
            const color = row.isWin ? '#4ade80' : '#f87171';
            const deltaText = (row.delta>0? `+${row.delta}` : `${row.delta}`);
            return `<div style="margin:4px 0;">
              ${row.date} | ${row.map}
              ${row.opponentText ? ` | vs ${row.opponentText}` : ''}
              | <b style="color:${color}">${row.isWin ? 'ìŠ¹' : 'íŒ¨'}</b>
              | <span style="color:${color}">${deltaText}</span>
              <span style="color:#aaa"> (í˜„ì¬ ELO: ${row.eloAfter})</span>
            </div>`;
          }).join('') || 'ê²½ê¸° ê¸°ë¡ ì—†ìŒ';

        const modal=document.getElementById('playerModal');
        modal.style.display='block';
        document.getElementById('closeModal').onclick=()=>modal.style.display='none';
        window.onclick=(e)=>{if(e.target===modal)modal.style.display='none';};
        window.addEventListener('keydown',(e)=>{if(e.key==='Escape')modal.style.display='none';},{once:true});
      }
      catch(err){ console.error('íŒì—… ë¡œì§ ì˜¤ë¥˜:', err); }
    }
  })();
  </script>

</body>
</html>
